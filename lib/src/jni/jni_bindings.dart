// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("example");

/// from: okhttp3.OkHttpClient$Builder
class OkHttpClient_Builder extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Builder> $type = type;

  OkHttpClient_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_BuilderType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "OkHttpClient_Builder__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder() {
    return OkHttpClient_Builder.fromRef(_new0().object);
  }

  static final _callTimeout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__callTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder callTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_callTimeout(reference, j, timeUnit.reference).object);
  }

  static final _callTimeout1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__callTimeout1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder callTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_callTimeout1(reference, duration.reference).object);
  }

  static final _connectTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__connectTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder connectTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_connectTimeout(reference, j, timeUnit.reference).object);
  }

  static final _connectTimeout1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__connectTimeout1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder connectTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_connectTimeout1(reference, duration.reference).object);
  }

  static final _readTimeout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__readTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder readTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_readTimeout(reference, j, timeUnit.reference).object);
  }

  static final _readTimeout1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__readTimeout1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder readTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_readTimeout1(reference, duration.reference).object);
  }

  static final _writeTimeout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__writeTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder writeTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_writeTimeout(reference, j, timeUnit.reference).object);
  }

  static final _writeTimeout1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__writeTimeout1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder writeTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_writeTimeout1(reference, duration.reference).object);
  }

  static final _pingInterval = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__pingInterval")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder pingInterval(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval(
    int j,
    jni.JObject timeUnit,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_pingInterval(reference, j, timeUnit.reference).object);
  }

  static final _pingInterval1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__pingInterval1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder pingInterval(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval1(
    jni.JObject duration,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_pingInterval1(reference, duration.reference).object);
  }

  static final _proxy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__proxy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder proxy(java.net.Proxy proxy)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxy(
    jni.JObject proxy,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_proxy(reference, proxy.reference).object);
  }

  static final _proxySelector = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__proxySelector")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder proxySelector(java.net.ProxySelector proxySelector)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxySelector(
    jni.JObject proxySelector,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_proxySelector(reference, proxySelector.reference).object);
  }

  static final _cookieJar = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__cookieJar")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder cookieJar(okhttp3.CookieJar cookieJar)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cookieJar(
    jni.JObject cookieJar,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_cookieJar(reference, cookieJar.reference).object);
  }

  static final _cache = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__cache")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder cache(okhttp3.Cache cache)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cache(
    jni.JObject cache,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_cache(reference, cache.reference).object);
  }

  static final _dns = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__dns")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder dns(okhttp3.Dns dns)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dns(
    jni.JObject dns,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_dns(reference, dns.reference).object);
  }

  static final _socketFactory = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__socketFactory")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder socketFactory(javax.net.SocketFactory socketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder socketFactory(
    jni.JObject socketFactory,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_socketFactory(reference, socketFactory.reference).object);
  }

  static final _sslSocketFactory = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__sslSocketFactory")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory(
    jni.JObject sSLSocketFactory,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(
        _sslSocketFactory(reference, sSLSocketFactory.reference).object);
  }

  static final _sslSocketFactory1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__sslSocketFactory1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory, javax.net.ssl.X509TrustManager x509TrustManager)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory1(
    jni.JObject sSLSocketFactory,
    jni.JObject x509TrustManager,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(_sslSocketFactory1(
            reference, sSLSocketFactory.reference, x509TrustManager.reference)
        .object);
  }

  static final _hostnameVerifier = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__hostnameVerifier")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder hostnameVerifier(javax.net.ssl.HostnameVerifier hostnameVerifier)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder hostnameVerifier(
    jni.JObject hostnameVerifier,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(
        _hostnameVerifier(reference, hostnameVerifier.reference).object);
  }

  static final _certificatePinner = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__certificatePinner")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder certificatePinner(okhttp3.CertificatePinner certificatePinner)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder certificatePinner(
    jni.JObject certificatePinner,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(
        _certificatePinner(reference, certificatePinner.reference).object);
  }

  static final _authenticator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__authenticator")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder authenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder authenticator(
    jni.JObject authenticator,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_authenticator(reference, authenticator.reference).object);
  }

  static final _proxyAuthenticator = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__proxyAuthenticator")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder proxyAuthenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxyAuthenticator(
    jni.JObject authenticator,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(
        _proxyAuthenticator(reference, authenticator.reference).object);
  }

  static final _connectionPool = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__connectionPool")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder connectionPool(okhttp3.ConnectionPool connectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionPool(
    jni.JObject connectionPool,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_connectionPool(reference, connectionPool.reference).object);
  }

  static final _followSslRedirects = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("OkHttpClient_Builder__followSslRedirects")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public okhttp3.OkHttpClient$Builder followSslRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followSslRedirects(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_followSslRedirects(reference, z ? 1 : 0).object);
  }

  static final _followRedirects = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("OkHttpClient_Builder__followRedirects")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public okhttp3.OkHttpClient$Builder followRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followRedirects(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_followRedirects(reference, z ? 1 : 0).object);
  }

  static final _retryOnConnectionFailure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("OkHttpClient_Builder__retryOnConnectionFailure")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public okhttp3.OkHttpClient$Builder retryOnConnectionFailure(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder retryOnConnectionFailure(
    bool z,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_retryOnConnectionFailure(reference, z ? 1 : 0).object);
  }

  static final _dispatcher = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__dispatcher")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder dispatcher(okhttp3.Dispatcher dispatcher)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dispatcher(
    jni.JObject dispatcher,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_dispatcher(reference, dispatcher.reference).object);
  }

  static final _protocols = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient_Builder__protocols")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder protocols(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder protocols(
    jni.JList<jni.JObject> list,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_protocols(reference, list.reference).object);
  }

  static final _connectionSpecs = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__connectionSpecs")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder connectionSpecs(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionSpecs(
    jni.JList<jni.JObject> list,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_connectionSpecs(reference, list.reference).object);
  }

  static final _interceptors = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__interceptors")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType())
        .fromRef(_interceptors(reference).object);
  }

  static final _addInterceptor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__addInterceptor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder addInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_addInterceptor(reference, interceptor.reference).object);
  }

  static final _networkInterceptors = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__networkInterceptors")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType())
        .fromRef(_networkInterceptors(reference).object);
  }

  static final _addNetworkInterceptor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__addNetworkInterceptor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder addNetworkInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addNetworkInterceptor(
    jni.JObject interceptor,
  ) {
    return const $OkHttpClient_BuilderType().fromRef(
        _addNetworkInterceptor(reference, interceptor.reference).object);
  }

  static final _eventListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__eventListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder eventListener(okhttp3.EventListener eventListener)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListener(
    jni.JObject eventListener,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_eventListener(reference, eventListener.reference).object);
  }

  static final _eventListenerFactory = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__eventListenerFactory")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder eventListenerFactory(okhttp3.EventListener$Factory factory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListenerFactory(
    jni.JObject factory0,
  ) {
    return const $OkHttpClient_BuilderType()
        .fromRef(_eventListenerFactory(reference, factory0.reference).object);
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient build()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient build() {
    return const $OkHttpClientType().fromRef(_build(reference).object);
  }
}

final class $OkHttpClient_BuilderType
    extends jni.JObjType<OkHttpClient_Builder> {
  const $OkHttpClient_BuilderType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient$Builder;";

  @override
  OkHttpClient_Builder fromRef(jni.JObjectPtr ref) =>
      OkHttpClient_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_BuilderType) &&
        other is $OkHttpClient_BuilderType;
  }
}

/// from: okhttp3.OkHttpClient
class OkHttpClient extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient> $type = type;

  OkHttpClient.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClientType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "OkHttpClient__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient() {
    return OkHttpClient.fromRef(_new0().object);
  }

  static final _callTimeoutMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__callTimeoutMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int callTimeoutMillis()
  int callTimeoutMillis() {
    return _callTimeoutMillis(reference).integer;
  }

  static final _connectTimeoutMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__connectTimeoutMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int connectTimeoutMillis()
  int connectTimeoutMillis() {
    return _connectTimeoutMillis(reference).integer;
  }

  static final _readTimeoutMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__readTimeoutMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int readTimeoutMillis()
  int readTimeoutMillis() {
    return _readTimeoutMillis(reference).integer;
  }

  static final _writeTimeoutMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__writeTimeoutMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int writeTimeoutMillis()
  int writeTimeoutMillis() {
    return _writeTimeoutMillis(reference).integer;
  }

  static final _pingIntervalMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__pingIntervalMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int pingIntervalMillis()
  int pingIntervalMillis() {
    return _pingIntervalMillis(reference).integer;
  }

  static final _proxy = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__proxy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.net.Proxy proxy()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxy() {
    return const jni.JObjectType().fromRef(_proxy(reference).object);
  }

  static final _proxySelector = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__proxySelector")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.net.ProxySelector proxySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxySelector() {
    return const jni.JObjectType().fromRef(_proxySelector(reference).object);
  }

  static final _cookieJar = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__cookieJar")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.CookieJar cookieJar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cookieJar() {
    return const jni.JObjectType().fromRef(_cookieJar(reference).object);
  }

  static final _cache = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__cache")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Cache cache()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cache() {
    return const jni.JObjectType().fromRef(_cache(reference).object);
  }

  static final _dns = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__dns")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Dns dns()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dns() {
    return const jni.JObjectType().fromRef(_dns(reference).object);
  }

  static final _socketFactory = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__socketFactory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public javax.net.SocketFactory socketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject socketFactory() {
    return const jni.JObjectType().fromRef(_socketFactory(reference).object);
  }

  static final _sslSocketFactory = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__sslSocketFactory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public javax.net.ssl.SSLSocketFactory sslSocketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject sslSocketFactory() {
    return const jni.JObjectType().fromRef(_sslSocketFactory(reference).object);
  }

  static final _hostnameVerifier = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__hostnameVerifier")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public javax.net.ssl.HostnameVerifier hostnameVerifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject hostnameVerifier() {
    return const jni.JObjectType().fromRef(_hostnameVerifier(reference).object);
  }

  static final _certificatePinner = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__certificatePinner")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.CertificatePinner certificatePinner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificatePinner() {
    return const jni.JObjectType()
        .fromRef(_certificatePinner(reference).object);
  }

  static final _authenticator = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__authenticator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Authenticator authenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject authenticator() {
    return const jni.JObjectType().fromRef(_authenticator(reference).object);
  }

  static final _proxyAuthenticator = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__proxyAuthenticator")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Authenticator proxyAuthenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxyAuthenticator() {
    return const jni.JObjectType()
        .fromRef(_proxyAuthenticator(reference).object);
  }

  static final _connectionPool = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__connectionPool")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.ConnectionPool connectionPool()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject connectionPool() {
    return const jni.JObjectType().fromRef(_connectionPool(reference).object);
  }

  static final _followSslRedirects = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__followSslRedirects")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean followSslRedirects()
  bool followSslRedirects() {
    return _followSslRedirects(reference).boolean;
  }

  static final _followRedirects = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__followRedirects")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean followRedirects()
  bool followRedirects() {
    return _followRedirects(reference).boolean;
  }

  static final _retryOnConnectionFailure = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__retryOnConnectionFailure")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean retryOnConnectionFailure()
  bool retryOnConnectionFailure() {
    return _retryOnConnectionFailure(reference).boolean;
  }

  static final _dispatcher = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__dispatcher")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Dispatcher dispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dispatcher() {
    return const jni.JObjectType().fromRef(_dispatcher(reference).object);
  }

  static final _protocols = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__protocols")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List protocols()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> protocols() {
    return const jni.JListType(jni.JObjectType())
        .fromRef(_protocols(reference).object);
  }

  static final _connectionSpecs = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__connectionSpecs")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List connectionSpecs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> connectionSpecs() {
    return const jni.JListType(jni.JObjectType())
        .fromRef(_connectionSpecs(reference).object);
  }

  static final _interceptors = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__interceptors")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return const jni.JListType(jni.JObjectType())
        .fromRef(_interceptors(reference).object);
  }

  static final _networkInterceptors = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__networkInterceptors")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return const jni.JListType(jni.JObjectType())
        .fromRef(_networkInterceptors(reference).object);
  }

  static final _eventListenerFactory = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__eventListenerFactory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.EventListener$Factory eventListenerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject eventListenerFactory() {
    return const jni.JObjectType()
        .fromRef(_eventListenerFactory(reference).object);
  }

  static final _newCall = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient__newCall")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return const $CallType()
        .fromRef(_newCall(reference, request.reference).object);
  }

  static final _newWebSocket = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OkHttpClient__newWebSocket")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.WebSocket newWebSocket(okhttp3.Request request, okhttp3.WebSocketListener webSocketListener)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject newWebSocket(
    Request request,
    jni.JObject webSocketListener,
  ) {
    return const jni.JObjectType().fromRef(
        _newWebSocket(reference, request.reference, webSocketListener.reference)
            .object);
  }

  static final _newBuilder = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OkHttpClient__newBuilder")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.OkHttpClient$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder newBuilder() {
    return const $OkHttpClient_BuilderType()
        .fromRef(_newBuilder(reference).object);
  }
}

final class $OkHttpClientType extends jni.JObjType<OkHttpClient> {
  const $OkHttpClientType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient;";

  @override
  OkHttpClient fromRef(jni.JObjectPtr ref) => OkHttpClient.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClientType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClientType) &&
        other is $OkHttpClientType;
  }
}

/// from: okhttp3.Call$Factory
class Call_Factory extends jni.JObject {
  @override
  late final jni.JObjType<Call_Factory> $type = type;

  Call_Factory.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Call_FactoryType();
  static final _newCall = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Call_Factory__newCall")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return const $CallType()
        .fromRef(_newCall(reference, request.reference).object);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Call_FactoryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"newCall(Lokhttp3/Request;)Lokhttp3/Call;") {
        final $r = _$impls[$p]!.newCall(
          $a[0].castTo(const $RequestType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Call_Factory.implement(
    $Call_FactoryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call_Factory.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Call$Factory",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Call_FactoryImpl {
  factory $Call_FactoryImpl({
    required Call Function(Request request) newCall,
  }) = _$Call_FactoryImpl;

  Call newCall(Request request);
}

class _$Call_FactoryImpl implements $Call_FactoryImpl {
  _$Call_FactoryImpl({
    required Call Function(Request request) newCall,
  }) : _newCall = newCall;

  final Call Function(Request request) _newCall;

  Call newCall(Request request) {
    return _newCall(request);
  }
}

final class $Call_FactoryType extends jni.JObjType<Call_Factory> {
  const $Call_FactoryType();

  @override
  String get signature => r"Lokhttp3/Call$Factory;";

  @override
  Call_Factory fromRef(jni.JObjectPtr ref) => Call_Factory.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Call_FactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call_FactoryType) &&
        other is $Call_FactoryType;
  }
}

/// from: okhttp3.Call
class Call extends jni.JObject {
  @override
  late final jni.JObjType<Call> $type = type;

  Call.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $CallType();
  static final _request = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Call__request")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return const $RequestType().fromRef(_request(reference).object);
  }

  static final _execute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Call__execute")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.Response execute()
  /// The returned object must be released after use, by calling the [release] method.
  Response execute() {
    return const $ResponseType().fromRef(_execute(reference).object);
  }

  static final _enqueue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Call__enqueue")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enqueue(okhttp3.Callback callback)
  void enqueue(
    Callback callback,
  ) {
    return _enqueue(reference, callback.reference).check();
  }

  static final _cancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Call__cancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void cancel()
  void cancel() {
    return _cancel(reference).check();
  }

  static final _isExecuted = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Call__isExecuted")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isExecuted()
  bool isExecuted() {
    return _isExecuted(reference).boolean;
  }

  static final _isCanceled = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Call__isCanceled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return _isCanceled(reference).boolean;
  }

  static final _timeout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Call__timeout")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject timeout() {
    return const jni.JObjectType().fromRef(_timeout(reference).object);
  }

  static final _clone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Call__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.Call clone()
  /// The returned object must be released after use, by calling the [release] method.
  Call clone() {
    return const $CallType().fromRef(_clone(reference).object);
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CallImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"request()Lokhttp3/Request;") {
        final $r = _$impls[$p]!.request();
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d == r"execute()Lokhttp3/Response;") {
        final $r = _$impls[$p]!.execute();
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d == r"enqueue(Lokhttp3/Callback;)V") {
        _$impls[$p]!.enqueue(
          $a[0].castTo(const $CallbackType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"cancel()V") {
        _$impls[$p]!.cancel();
        return jni.nullptr;
      }
      if ($d == r"isExecuted()Z") {
        final $r = _$impls[$p]!.isExecuted();
        return jni.JBoolean($r).toPointer();
      }
      if ($d == r"isCanceled()Z") {
        final $r = _$impls[$p]!.isCanceled();
        return jni.JBoolean($r).toPointer();
      }
      if ($d == r"timeout()Lokio/Timeout;") {
        final $r = _$impls[$p]!.timeout();
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d == r"clone()Lokhttp3/Call;") {
        final $r = _$impls[$p]!.clone();
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Call.implement(
    $CallImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Call",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $CallImpl {
  factory $CallImpl({
    required Request Function() request,
    required Response Function() execute,
    required void Function(Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  }) = _$CallImpl;

  Request request();
  Response execute();
  void enqueue(Callback callback);
  void cancel();
  bool isExecuted();
  bool isCanceled();
  jni.JObject timeout();
  Call clone();
}

class _$CallImpl implements $CallImpl {
  _$CallImpl({
    required Request Function() request,
    required Response Function() execute,
    required void Function(Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  })  : _request = request,
        _execute = execute,
        _enqueue = enqueue,
        _cancel = cancel,
        _isExecuted = isExecuted,
        _isCanceled = isCanceled,
        _timeout = timeout,
        _clone = clone;

  final Request Function() _request;
  final Response Function() _execute;
  final void Function(Callback callback) _enqueue;
  final void Function() _cancel;
  final bool Function() _isExecuted;
  final bool Function() _isCanceled;
  final jni.JObject Function() _timeout;
  final Call Function() _clone;

  Request request() {
    return _request();
  }

  Response execute() {
    return _execute();
  }

  void enqueue(Callback callback) {
    return _enqueue(callback);
  }

  void cancel() {
    return _cancel();
  }

  bool isExecuted() {
    return _isExecuted();
  }

  bool isCanceled() {
    return _isCanceled();
  }

  jni.JObject timeout() {
    return _timeout();
  }

  Call clone() {
    return _clone();
  }
}

final class $CallType extends jni.JObjType<Call> {
  const $CallType();

  @override
  String get signature => r"Lokhttp3/Call;";

  @override
  Call fromRef(jni.JObjectPtr ref) => Call.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallType) && other is $CallType;
  }
}

/// from: okhttp3.Callback
class Callback extends jni.JObject {
  @override
  late final jni.JObjType<Callback> $type = type;

  Callback.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $CallbackType();
  static final _onFailure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Callback__onFailure")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFailure(okhttp3.Call call, java.io.IOException iOException)
  void onFailure(
    Call call,
    jni.JObject iOException,
  ) {
    return _onFailure(reference, call.reference, iOException.reference).check();
  }

  static final _onResponse = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Callback__onResponse")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onResponse(okhttp3.Call call, okhttp3.Response response)
  void onResponse(
    Call call,
    Response response,
  ) {
    return _onResponse(reference, call.reference, response.reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFailure(Lokhttp3/Call;Ljava/io/IOException;)V") {
        _$impls[$p]!.onFailure(
          $a[0].castTo(const $CallType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"onResponse(Lokhttp3/Call;Lokhttp3/Response;)V") {
        _$impls[$p]!.onResponse(
          $a[0].castTo(const $CallType(), releaseOriginal: true),
          $a[1].castTo(const $ResponseType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Callback.implement(
    $CallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Callback.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Callback",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $CallbackImpl {
  factory $CallbackImpl({
    required void Function(Call call, jni.JObject iOException) onFailure,
    required void Function(Call call, Response response) onResponse,
  }) = _$CallbackImpl;

  void onFailure(Call call, jni.JObject iOException);
  void onResponse(Call call, Response response);
}

class _$CallbackImpl implements $CallbackImpl {
  _$CallbackImpl({
    required void Function(Call call, jni.JObject iOException) onFailure,
    required void Function(Call call, Response response) onResponse,
  })  : _onFailure = onFailure,
        _onResponse = onResponse;

  final void Function(Call call, jni.JObject iOException) _onFailure;
  final void Function(Call call, Response response) _onResponse;

  void onFailure(Call call, jni.JObject iOException) {
    return _onFailure(call, iOException);
  }

  void onResponse(Call call, Response response) {
    return _onResponse(call, response);
  }
}

final class $CallbackType extends jni.JObjType<Callback> {
  const $CallbackType();

  @override
  String get signature => r"Lokhttp3/Callback;";

  @override
  Callback fromRef(jni.JObjectPtr ref) => Callback.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallbackType) && other is $CallbackType;
  }
}

/// from: okhttp3.MediaType
class MediaType extends jni.JObject {
  @override
  late final jni.JObjType<MediaType> $type = type;

  MediaType.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $MediaTypeType();
  static final _get0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("MediaType__get0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public okhttp3.MediaType get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static MediaType get0(
    jni.JString string,
  ) {
    return const $MediaTypeType().fromRef(_get0(string.reference).object);
  }

  static final _parse = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaType__parse")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public okhttp3.MediaType parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static MediaType parse(
    jni.JString string,
  ) {
    return const $MediaTypeType().fromRef(_parse(string.reference).object);
  }

  static final _type0 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaType__type0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String type()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString type0() {
    return const jni.JStringType().fromRef(_type0(reference).object);
  }

  static final _subtype = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaType__subtype")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String subtype()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString subtype() {
    return const jni.JStringType().fromRef(_subtype(reference).object);
  }

  static final _charset = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaType__charset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.nio.charset.Charset charset()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charset() {
    return const jni.JObjectType().fromRef(_charset(reference).object);
  }

  static final _charset1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MediaType__charset1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.nio.charset.Charset charset(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charset1(
    jni.JObject charset,
  ) {
    return const jni.JObjectType()
        .fromRef(_charset1(reference, charset.reference).object);
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaType__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MediaType__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference, object.reference).boolean;
  }

  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaType__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference).integer;
  }
}

final class $MediaTypeType extends jni.JObjType<MediaType> {
  const $MediaTypeType();

  @override
  String get signature => r"Lokhttp3/MediaType;";

  @override
  MediaType fromRef(jni.JObjectPtr ref) => MediaType.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($MediaTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($MediaTypeType) && other is $MediaTypeType;
  }
}

/// from: okhttp3.Request$Builder
class Request_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Request_Builder> $type = type;

  Request_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Request_BuilderType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Request_Builder__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder() {
    return Request_Builder.fromRef(_new0().object);
  }

  static final _url = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__url")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url(
    jni.JObject httpUrl,
  ) {
    return const $Request_BuilderType()
        .fromRef(_url(reference, httpUrl.reference).object);
  }

  static final _url1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__url1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url1(
    jni.JString string,
  ) {
    return const $Request_BuilderType()
        .fromRef(_url1(reference, string.reference).object);
  }

  static final _url2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__url2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url2(
    jni.JObject uRL,
  ) {
    return const $Request_BuilderType()
        .fromRef(_url2(reference, uRL.reference).object);
  }

  static final _header = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__header")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Request_BuilderType().fromRef(
        _header(reference, string.reference, string1.reference).object);
  }

  static final _addHeader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__addHeader")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Request_BuilderType().fromRef(
        _addHeader(reference, string.reference, string1.reference).object);
  }

  static final _removeHeader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__removeHeader")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder removeHeader(
    jni.JString string,
  ) {
    return const $Request_BuilderType()
        .fromRef(_removeHeader(reference, string.reference).object);
  }

  static final _headers = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__headers")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder headers(
    jni.JObject headers,
  ) {
    return const $Request_BuilderType()
        .fromRef(_headers(reference, headers.reference).object);
  }

  static final _cacheControl = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__cacheControl")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder cacheControl(okhttp3.CacheControl cacheControl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder cacheControl(
    jni.JObject cacheControl,
  ) {
    return const $Request_BuilderType()
        .fromRef(_cacheControl(reference, cacheControl.reference).object);
  }

  static final _get0 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request_Builder__get0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder get()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder get0() {
    return const $Request_BuilderType().fromRef(_get0(reference).object);
  }

  static final _head = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request_Builder__head")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder head()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder head() {
    return const $Request_BuilderType().fromRef(_head(reference).object);
  }

  static final _post = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__post")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder post(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder post(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType()
        .fromRef(_post(reference, requestBody.reference).object);
  }

  static final _delete = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__delete")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder delete(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType()
        .fromRef(_delete(reference, requestBody.reference).object);
  }

  static final _delete1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request_Builder__delete1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder delete()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete1() {
    return const $Request_BuilderType().fromRef(_delete1(reference).object);
  }

  static final _put = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__put")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder put(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder put(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType()
        .fromRef(_put(reference, requestBody.reference).object);
  }

  static final _patch = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__patch")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder patch(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder patch(
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType()
        .fromRef(_patch(reference, requestBody.reference).object);
  }

  static final _method = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__method")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder method(java.lang.String string, okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder method(
    jni.JString string,
    RequestBody requestBody,
  ) {
    return const $Request_BuilderType().fromRef(
        _method(reference, string.reference, requestBody.reference).object);
  }

  static final _tag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__tag")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder tag(java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag(
    jni.JObject object,
  ) {
    return const $Request_BuilderType()
        .fromRef(_tag(reference, object.reference).object);
  }

  static final _tag1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request_Builder__tag1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder tag(java.lang.Class class, T object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag1<$T extends jni.JObject>(
    jni.JObject class0,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return const $Request_BuilderType()
        .fromRef(_tag1(reference, class0.reference, object.reference).object);
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request build()
  /// The returned object must be released after use, by calling the [release] method.
  Request build() {
    return const $RequestType().fromRef(_build(reference).object);
  }
}

final class $Request_BuilderType extends jni.JObjType<Request_Builder> {
  const $Request_BuilderType();

  @override
  String get signature => r"Lokhttp3/Request$Builder;";

  @override
  Request_Builder fromRef(jni.JObjectPtr ref) => Request_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Request_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request_BuilderType) &&
        other is $Request_BuilderType;
  }
}

/// from: okhttp3.Request
class Request extends jni.JObject {
  @override
  late final jni.JObjType<Request> $type = type;

  Request.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $RequestType();
  static final _url = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Request__url")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.HttpUrl url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject url() {
    return const jni.JObjectType().fromRef(_url(reference).object);
  }

  static final _method = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Request__method")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String method()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString method() {
    return const jni.JStringType().fromRef(_method(reference).object);
  }

  static final _headers = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request__headers")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject headers() {
    return const jni.JObjectType().fromRef(_headers(reference).object);
  }

  static final _header = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request__header")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
  ) {
    return const jni.JStringType()
        .fromRef(_header(reference, string.reference).object);
  }

  static final _headers1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request__headers1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType())
        .fromRef(_headers1(reference, string.reference).object);
  }

  static final _body = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Request__body")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.RequestBody body()
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody body() {
    return const $RequestBodyType().fromRef(_body(reference).object);
  }

  static final _tag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Request__tag")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object tag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject tag() {
    return const jni.JObjectType().fromRef(_tag(reference).object);
  }

  static final _tag1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Request__tag1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public T tag(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $T tag1<$T extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$T> T,
  }) {
    return T.fromRef(_tag1(reference, class0.reference).object);
  }

  static final _newBuilder = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request__newBuilder")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder newBuilder() {
    return const $Request_BuilderType().fromRef(_newBuilder(reference).object);
  }

  static final _cacheControl = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request__cacheControl")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(_cacheControl(reference).object);
  }

  static final _isHttps = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request__isHttps")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isHttps()
  bool isHttps() {
    return _isHttps(reference).boolean;
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Request__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }
}

final class $RequestType extends jni.JObjType<Request> {
  const $RequestType();

  @override
  String get signature => r"Lokhttp3/Request;";

  @override
  Request fromRef(jni.JObjectPtr ref) => Request.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestType) && other is $RequestType;
  }
}

/// from: okhttp3.RequestBody
class RequestBody extends jni.JObject {
  @override
  late final jni.JObjType<RequestBody> $type = type;

  RequestBody.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $RequestBodyType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "RequestBody__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory RequestBody() {
    return RequestBody.fromRef(_new0().object);
  }

  static final _contentType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "RequestBody__contentType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  MediaType contentType() {
    return const $MediaTypeType().fromRef(_contentType(reference).object);
  }

  static final _contentLength = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "RequestBody__contentLength")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long contentLength()
  int contentLength() {
    return _contentLength(reference).long;
  }

  static final _writeTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RequestBody__writeTo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void writeTo(okio.BufferedSink bufferedSink)
  void writeTo(
    jni.JObject bufferedSink,
  ) {
    return _writeTo(reference, bufferedSink.reference).check();
  }

  static final _isDuplex = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "RequestBody__isDuplex")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDuplex()
  bool isDuplex() {
    return _isDuplex(reference).boolean;
  }

  static final _isOneShot = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "RequestBody__isOneShot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isOneShot()
  bool isOneShot() {
    return _isOneShot(reference).boolean;
  }

  static final _create = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RequestBody__create")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create(
    MediaType mediaType,
    jni.JString string,
  ) {
    return const $RequestBodyType()
        .fromRef(_create(mediaType.reference, string.reference).object);
  }

  static final _create1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RequestBody__create1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create1(
    MediaType mediaType,
    jni.JObject byteString,
  ) {
    return const $RequestBodyType()
        .fromRef(_create1(mediaType.reference, byteString.reference).object);
  }

  static final _create2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RequestBody__create2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create2(
    MediaType mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $RequestBodyType()
        .fromRef(_create2(mediaType.reference, bs.reference).object);
  }

  static final _create3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("RequestBody__create3")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create3(
    MediaType mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $RequestBodyType()
        .fromRef(_create3(mediaType.reference, bs.reference, i, i1).object);
  }

  static final _create4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RequestBody__create4")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create4(
    MediaType mediaType,
    jni.JObject file,
  ) {
    return const $RequestBodyType()
        .fromRef(_create4(mediaType.reference, file.reference).object);
  }
}

final class $RequestBodyType extends jni.JObjType<RequestBody> {
  const $RequestBodyType();

  @override
  String get signature => r"Lokhttp3/RequestBody;";

  @override
  RequestBody fromRef(jni.JObjectPtr ref) => RequestBody.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBodyType) && other is $RequestBodyType;
  }
}

/// from: okhttp3.Response$Builder
class Response_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Response_Builder> $type = type;

  Response_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Response_BuilderType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Response_Builder__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder() {
    return Response_Builder.fromRef(_new0().object);
  }

  static final _request = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__request")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder request(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder request(
    Request request,
  ) {
    return const $Response_BuilderType()
        .fromRef(_request(reference, request.reference).object);
  }

  static final _protocol = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__protocol")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder protocol(okhttp3.Protocol protocol)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder protocol(
    jni.JObject protocol,
  ) {
    return const $Response_BuilderType()
        .fromRef(_protocol(reference, protocol.reference).object);
  }

  static final _code = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Response_Builder__code")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public okhttp3.Response$Builder code(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder code(
    int i,
  ) {
    return const $Response_BuilderType().fromRef(_code(reference, i).object);
  }

  static final _message = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__message")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder message(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder message(
    jni.JString string,
  ) {
    return const $Response_BuilderType()
        .fromRef(_message(reference, string.reference).object);
  }

  static final _handshake = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__handshake")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder handshake(okhttp3.Handshake handshake)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder handshake(
    jni.JObject handshake,
  ) {
    return const $Response_BuilderType()
        .fromRef(_handshake(reference, handshake.reference).object);
  }

  static final _header = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__header")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Response_BuilderType().fromRef(
        _header(reference, string.reference, string1.reference).object);
  }

  static final _addHeader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__addHeader")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Response_BuilderType().fromRef(
        _addHeader(reference, string.reference, string1.reference).object);
  }

  static final _removeHeader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__removeHeader")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder removeHeader(
    jni.JString string,
  ) {
    return const $Response_BuilderType()
        .fromRef(_removeHeader(reference, string.reference).object);
  }

  static final _headers = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__headers")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder headers(
    jni.JObject headers,
  ) {
    return const $Response_BuilderType()
        .fromRef(_headers(reference, headers.reference).object);
  }

  static final _body = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__body")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder body(okhttp3.ResponseBody responseBody)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder body(
    jni.JObject responseBody,
  ) {
    return const $Response_BuilderType()
        .fromRef(_body(reference, responseBody.reference).object);
  }

  static final _networkResponse = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__networkResponse")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder networkResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder networkResponse(
    Response response,
  ) {
    return const $Response_BuilderType()
        .fromRef(_networkResponse(reference, response.reference).object);
  }

  static final _cacheResponse = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__cacheResponse")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder cacheResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder cacheResponse(
    Response response,
  ) {
    return const $Response_BuilderType()
        .fromRef(_cacheResponse(reference, response.reference).object);
  }

  static final _priorResponse = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response_Builder__priorResponse")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder priorResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder priorResponse(
    Response response,
  ) {
    return const $Response_BuilderType()
        .fromRef(_priorResponse(reference, response.reference).object);
  }

  static final _sentRequestAtMillis = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("Response_Builder__sentRequestAtMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public okhttp3.Response$Builder sentRequestAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder sentRequestAtMillis(
    int j,
  ) {
    return const $Response_BuilderType()
        .fromRef(_sentRequestAtMillis(reference, j).object);
  }

  static final _receivedResponseAtMillis = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("Response_Builder__receivedResponseAtMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public okhttp3.Response$Builder receivedResponseAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder receivedResponseAtMillis(
    int j,
  ) {
    return const $Response_BuilderType()
        .fromRef(_receivedResponseAtMillis(reference, j).object);
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response build()
  /// The returned object must be released after use, by calling the [release] method.
  Response build() {
    return const $ResponseType().fromRef(_build(reference).object);
  }
}

final class $Response_BuilderType extends jni.JObjType<Response_Builder> {
  const $Response_BuilderType();

  @override
  String get signature => r"Lokhttp3/Response$Builder;";

  @override
  Response_Builder fromRef(jni.JObjectPtr ref) => Response_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Response_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response_BuilderType) &&
        other is $Response_BuilderType;
  }
}

/// from: okhttp3.Response
class Response extends jni.JObject {
  @override
  late final jni.JObjType<Response> $type = type;

  Response.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseType();
  static final _request = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__request")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return const $RequestType().fromRef(_request(reference).object);
  }

  static final _protocol = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__protocol")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Protocol protocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject protocol() {
    return const jni.JObjectType().fromRef(_protocol(reference).object);
  }

  static final _code = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Response__code")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int code()
  int code() {
    return _code(reference).integer;
  }

  static final _isSuccessful = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__isSuccessful")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isSuccessful()
  bool isSuccessful() {
    return _isSuccessful(reference).boolean;
  }

  static final _message = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__message")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String message()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString message() {
    return const jni.JStringType().fromRef(_message(reference).object);
  }

  static final _handshake = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__handshake")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Handshake handshake()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject handshake() {
    return const jni.JObjectType().fromRef(_handshake(reference).object);
  }

  static final _headers = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response__headers")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType())
        .fromRef(_headers(reference, string.reference).object);
  }

  static final _header = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response__header")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
  ) {
    return const jni.JStringType()
        .fromRef(_header(reference, string.reference).object);
  }

  static final _header1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Response__header1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header1(
    jni.JString string,
    jni.JString string1,
  ) {
    return const jni.JStringType().fromRef(
        _header1(reference, string.reference, string1.reference).object);
  }

  static final _headers1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__headers1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject headers1() {
    return const jni.JObjectType().fromRef(_headers1(reference).object);
  }

  static final _trailers = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__trailers")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Headers trailers()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject trailers() {
    return const jni.JObjectType().fromRef(_trailers(reference).object);
  }

  static final _peekBody = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int64)>>("Response__peekBody")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public okhttp3.ResponseBody peekBody(long j)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject peekBody(
    int j,
  ) {
    return const jni.JObjectType().fromRef(_peekBody(reference, j).object);
  }

  static final _body = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Response__body")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.ResponseBody body()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject body() {
    return const jni.JObjectType().fromRef(_body(reference).object);
  }

  static final _newBuilder = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__newBuilder")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder newBuilder() {
    return const $Response_BuilderType().fromRef(_newBuilder(reference).object);
  }

  static final _isRedirect = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__isRedirect")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRedirect()
  bool isRedirect() {
    return _isRedirect(reference).boolean;
  }

  static final _networkResponse = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__networkResponse")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response networkResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response networkResponse() {
    return const $ResponseType().fromRef(_networkResponse(reference).object);
  }

  static final _cacheResponse = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__cacheResponse")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response cacheResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response cacheResponse() {
    return const $ResponseType().fromRef(_cacheResponse(reference).object);
  }

  static final _priorResponse = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__priorResponse")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response priorResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response priorResponse() {
    return const $ResponseType().fromRef(_priorResponse(reference).object);
  }

  static final _challenges = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__challenges")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List challenges()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> challenges() {
    return const jni.JListType(jni.JObjectType())
        .fromRef(_challenges(reference).object);
  }

  static final _cacheControl = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__cacheControl")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return const jni.JObjectType().fromRef(_cacheControl(reference).object);
  }

  static final _sentRequestAtMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__sentRequestAtMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long sentRequestAtMillis()
  int sentRequestAtMillis() {
    return _sentRequestAtMillis(reference).long;
  }

  static final _receivedResponseAtMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__receivedResponseAtMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long receivedResponseAtMillis()
  int receivedResponseAtMillis() {
    return _receivedResponseAtMillis(reference).long;
  }

  static final _close = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Response__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  void close() {
    return _close(reference).check();
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Response__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }
}

final class $ResponseType extends jni.JObjType<Response> {
  const $ResponseType();

  @override
  String get signature => r"Lokhttp3/Response;";

  @override
  Response fromRef(jni.JObjectPtr ref) => Response.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseType) && other is $ResponseType;
  }
}
